#include <IRremote.h>
#include "Freenove_WS2812_Lib_for_ESP32.h"
#include <Adafruit_SSD1306.h>  


#define MAX_Col_Val 255   //Max color value
#define LEDS_COUNT  60    //How much LED's have our strip                                                                  
#define LEDS_PIN  2       //Pin in where to put command cable from LED strip
#define CHANNEL   0
#define MAX_SPACE 60      
#define MAX_ROW   60
#define MAX_FREQ  120
#define MAX_BRIGHTNESS  255
Freenove_ESP32_WS2812 strip = Freenove_ESP32_WS2812(LEDS_COUNT, LEDS_PIN, CHANNEL, TYPE_GRB); //Led strip setup 

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1           //There is no reset button for OLED, so "-1"
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);   //Display setup                    


const byte IR_RECEIVE_PIN = 15;   //ir reciver setup
//const int ledPin =  5;          //pin for test, uncomment if needed

int color[6][3]={{0, 0, 0}, {255, 0, 0}, {0, 255, 0}, {0, 0, 255},{255, 255, 255},{0, 0, 0}};     //none color, red, green, blue, user's -any inputed color (starts as none)
String menu_setup[5]={"Red________", "Green______", "Blue_______", "Freqency___    Hz","Mode_______"};  //Menu text for displaing
String mode_setup[3]={"Multi", "Single", "Pause"};                                                      //↑
int col_nr=0;   //Value of first index of color[][]
int col_r=0;    //Value of red
int col_g=0;    //Value of green
int col_b=0;    //Value of blue
int freq=1;     //Value of frequency
int space=3;    //Space - How many blank LED's should be between last diode in row before and first diode of next row
int row=1;      //Row - how many LED's should be lighted in a row
int address=0;  //Addres - start adress of the first diode, due to it pusshing the diodes in relative direction
int k_counter=0;//Changing the mode (Multi diode/Single diode/Pause)
char prev_command=' '; //Default value of first command

TaskHandle_t Task0;
TaskHandle_t Task1;

static const unsigned char PROGMEM logo16_glcd_bmp[] =   //Logo PolSl
{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xfc, 0x03, 0xf9, 0xff, 0xff, 
  0xe0, 0x7f, 0xc9, 0xdf, 0xff, 0xcf, 0xff, 0x27, 0xff, 0xff, 0xe0, 0xc0, 0x00, 0x70, 0x7f, 0xff, 
  0xe7, 0x3f, 0xcf, 0x9f, 0xff, 0xcf, 0xff, 0xe7, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 
  0xe7, 0x30, 0xc9, 0x08, 0x70, 0xc9, 0x93, 0x26, 0x61, 0xff, 0x80, 0x00, 0x00, 0x00, 0x1f, 0xff, 
  0xe7, 0x26, 0x49, 0x93, 0x26, 0x44, 0x89, 0x24, 0xdc, 0xff, 0xc0, 0x07, 0xfe, 0x00, 0x1f, 0xff, 
  0xe7, 0x26, 0x49, 0x93, 0x27, 0xcc, 0x99, 0x21, 0xf0, 0xff, 0xc0, 0x3f, 0xff, 0x80, 0x1f, 0xff, 
  0xe0, 0x66, 0x49, 0x90, 0x27, 0xcc, 0x99, 0x20, 0xe4, 0xff, 0x80, 0x78, 0x00, 0xf0, 0x0f, 0xff, 
  0xe7, 0xe6, 0x49, 0x93, 0xe7, 0xcc, 0x99, 0x24, 0xcc, 0xff, 0x01, 0xc0, 0x60, 0x38, 0x07, 0xff, 
  0xe7, 0xe6, 0x49, 0x93, 0x26, 0x4c, 0x99, 0x26, 0x4c, 0xfe, 0x07, 0x83, 0xb0, 0x0e, 0x03, 0xff, 
  0xe7, 0xf0, 0xc9, 0xc8, 0x70, 0xcc, 0x99, 0x26, 0x60, 0xe4, 0x0e, 0x07, 0x98, 0x07, 0x01, 0x3f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x1c, 0x41, 0xfc, 0x11, 0x80, 0x3f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x39, 0xe0, 0xf8, 0x78, 0xc0, 0x1f, 
  0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x73, 0xb0, 0xf0, 0x5c, 0x60, 0x1f, 
  0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xe3, 0x30, 0xf0, 0xc4, 0x30, 0x0f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc2, 0x30, 0xf0, 0xc4, 0x38, 0x0f, 
  0xff, 0xff, 0xe0, 0xcf, 0xff, 0xe7, 0xff, 0xff, 0xff, 0x01, 0x83, 0xb0, 0xf0, 0x6e, 0x18, 0x0f, 
  0xff, 0xff, 0xce, 0x4f, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xc1, 0x83, 0xa0, 0xf8, 0x6e, 0x0c, 0x3f, 
  0xff, 0xff, 0xcf, 0xcc, 0x38, 0x66, 0x61, 0xff, 0xff, 0xc3, 0x07, 0xa1, 0xf0, 0x6e, 0x0c, 0x3f, 
  0xff, 0xff, 0xc3, 0xcb, 0x93, 0x24, 0xdc, 0xff, 0xff, 0x86, 0x0f, 0xb9, 0xfd, 0xdf, 0x06, 0x1f, 
  0xff, 0xff, 0xe0, 0xce, 0x11, 0xe1, 0xf0, 0xff, 0xff, 0x86, 0x0f, 0xdf, 0xff, 0xbf, 0x06, 0x1f, 
  0xff, 0xff, 0xf8, 0x4c, 0x98, 0x60, 0xe4, 0xff, 0xff, 0x86, 0x1f, 0xcf, 0xff, 0xbf, 0x83, 0x1f, 
  0xff, 0xff, 0xfe, 0x49, 0x9e, 0x24, 0xcc, 0xff, 0xff, 0x8c, 0x3f, 0xe7, 0xfe, 0x7f, 0xc3, 0x0f, 
  0xff, 0xff, 0xce, 0x49, 0x93, 0x26, 0x4c, 0xff, 0xfc, 0x0c, 0x7f, 0xf0, 0x00, 0xff, 0xe3, 0x01, 
  0xff, 0xff, 0xe0, 0xcc, 0x18, 0x66, 0x60, 0xff, 0xf8, 0x0c, 0xdf, 0xfc, 0x03, 0xff, 0xb3, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xf8, 0x0c, 0x1f, 0xff, 0xff, 0xff, 0x83, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xf8, 0x0c, 0x1f, 0xff, 0xff, 0xff, 0x81, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0c, 0x1f, 0xfd, 0xfb, 0xff, 0xc1, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0c, 0x3f, 0xfd, 0xfb, 0xff, 0xc3, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0c, 0x37, 0xfd, 0xf9, 0x7f, 0xe3, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0c, 0x67, 0xe8, 0xf9, 0x7f, 0x63, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8c, 0xce, 0xe3, 0xfc, 0x7f, 0x13, 0x0f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x84, 0x0e, 0x8f, 0xff, 0x9f, 0x03, 0x1f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x86, 0x0d, 0xbf, 0xff, 0xdb, 0x82, 0x1f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc2, 0x18, 0x3c, 0xf3, 0xc1, 0x86, 0x1f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x10, 0x79, 0xf9, 0xc0, 0xcc, 0x3f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x03, 0x63, 0xfc, 0x6e, 0x0c, 0x3f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0x81, 0xc1, 0xf8, 0x38, 0x18, 0x0f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc7, 0xec, 0xf3, 0x7e, 0x18, 0x07, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc5, 0xaf, 0xff, 0x5a, 0x30, 0x0f, 
  0xbb, 0xbf, 0xbf, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0x80, 0x63, 0x2f, 0xff, 0x0c, 0x60, 0x0f, 
  0xbb, 0xbf, 0xbf, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0x80, 0x30, 0x07, 0xfe, 0x00, 0xc0, 0x1f, 
  0xd5, 0x6e, 0xb6, 0x30, 0xc3, 0x97, 0xff, 0xff, 0xff, 0xc0, 0x18, 0x01, 0xf8, 0x01, 0x80, 0x1f, 
  0xd5, 0x75, 0xad, 0xd7, 0x7d, 0xbf, 0xff, 0xff, 0xff, 0xe0, 0x0e, 0x00, 0xf0, 0x03, 0x00, 0x3f, 
  0xd5, 0x75, 0x9d, 0xd7, 0x61, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0x07, 0x00, 0x60, 0x0e, 0x03, 0x7f, 
  0xee, 0xf5, 0xad, 0xd7, 0x5d, 0xbf, 0xff, 0xff, 0xff, 0xfe, 0x01, 0xc0, 0x60, 0x3c, 0x07, 0xff, 
  0xee, 0xfb, 0xb6, 0x37, 0x61, 0xb7, 0xff, 0xff, 0xff, 0xff, 0x00, 0xf0, 0x00, 0x70, 0x0f, 0xff, 
  0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3f, 0xdf, 0xc0, 0x1f, 0xff, 
  0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0f, 0xff, 0x00, 0x1f, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x1f, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x1f, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xc0, 0x00, 0x30, 0x7f, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xfc, 0x01, 0xf0, 0xff, 0xff, 
  0xf7, 0xbf, 0xbf, 0xff, 0xff, 0xf7, 0xff, 0xe3, 0x7a, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 
  0xeb, 0xbf, 0xbf, 0xff, 0xff, 0xf7, 0xff, 0xdd, 0x7e, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 
  0xeb, 0xb1, 0xb6, 0x10, 0xc3, 0x86, 0x31, 0xdf, 0x6a, 0x18, 0x7f, 0xfc, 0x03, 0xff, 0xff, 0xff, 
  0xdd, 0xae, 0xad, 0xff, 0x5d, 0x75, 0xd7, 0xe3, 0x5a, 0xef, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xc1, 0xa0, 0x9e, 0x38, 0x5d, 0x74, 0x17, 0xfd, 0x3a, 0xec, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xdd, 0xaf, 0xaf, 0xd7, 0x5d, 0x75, 0xf7, 0xdd, 0x5a, 0xeb, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xbe, 0xb0, 0xb4, 0x38, 0x5d, 0x86, 0x17, 0xe3, 0x6a, 0x1c, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};




void Menu(){ 
  color[5][0]=col_r;      //Assigning value of red color
  color[5][1]=col_g;      //Assigning value of green color
  color[5][2]=col_b;      //Assigning value of blue color
  int menu_data[4] ={color[col_nr][0], color[col_nr][1], color[col_nr][2],freq};  //creating matrix of color and frequency to display  
  display.clearDisplay();   // Clear the buffer.
  for (int i=0;i<5;i++){
    display.setCursor(5, 10*i);
    display.println(menu_setup[i]);   //displaying the menu text
    display.setCursor(71, 10*i);
    if (i!=4)
      display.println(menu_data[i]);  //displaying the values
    else
      display.println(mode_setup[k_counter]); //displaying the mode of device
    }
  if(k_counter!=2){           //displaying the text and values of Space, Row and Addres
    if(k_counter==0){  
      display.setCursor(5, 50);
      display.println("Spc:");
      display.setCursor(30, 50);
      display.println(space-1);
      
      display.setCursor(45, 50);
      display.println("Row:" );
      display.setCursor(70, 50);
      display.println(row);
      
      display.setCursor(85, 50);
      display.println("Addr:");
      display.setCursor(115, 50);
      display.println(address);  
      }
    else if (k_counter==1){
      display.setCursor(85, 50);
      display.println("Addr:");
      display.setCursor(115, 50);
      display.println(address);   
      }
  }
  display.display(); 
}


char Button(){   
   char button=' ';                               //Default value of button
   if (IrReceiver.decode()){                      //If there is a signal...
      switch(IrReceiver.decodedIRData.command){   //Read the command and translate it for assigned sign for clarity
      case 69: button='1'; break; //1
      case 70: button='2'; break; //2
      case 71: button='3'; break; //3
      case 68: button='4'; break; //4
      case 64: button='5'; break; //5
      case 67: button='6'; break; //6
      case 7:  button='7'; break; //7
      case 21: button='8'; break; //8
      case 9:  button='9'; break; //9
      case 22: button='*'; break; //*
      case 25: button='0'; break; //0
      case 13: button='#'; break; //#
      case 24: button='u'; break;   //up
      case 8:  button='l'; break;   //left
      case 28: button='k'; break;   //ok
      case 90: button='r'; break;   //right
      case 82: button='d'; break;   //down    
      default:   break;  
      }  
      IrReceiver.resume();                      //Stanby mode, resume reading and waiting for next command
   }
   return button;                               //Returning a sign of command
}

void setup(){
  //pinMode(ledPin, OUTPUT);                   //pin for test, uncomment if needed
  Serial.begin(9600);                          //OLED setup
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);   // OLED init done
  
  display.clearDisplay();                                 // Clear the screen
  display.drawBitmap(0,0, logo16_glcd_bmp, 128,64,WHITE); // Show logo of Politechnika Sląska
  display.display();                                      //Display buffor on screen
  delay(4000);                                            //Time how long the logo shows up
    
  display.clearDisplay();                // Clear the screen
  display.setTextSize(1);                // Text's size setup for 1 (minimum)
  display.setTextColor(SSD1306_WHITE);   //Text's color setup for white
  Menu();                                //Writing text of menu and default values
  
  Serial.begin(115200);                                  //IR Recive setup
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK); //Setting whitch pin is for getting command from IR remote
                                                         //And enabling LED on IR circuit after getting signal, usefull for checking is there any interference

  strip.begin();                        //Strip setup
  strip.setBrightness(MAX_BRIGHTNESS);  //LED's brightnes setup
  
  xTaskCreatePinnedToCore(                            //Task_1 creation
    loop1,    //Function for the task 
    "Task1",  //Name of the task
    10000,     //Stack size (word)
    NULL,     ///Variable input type
    0,        //Piority
    &Task1,   //Task handle address
    1);       //Task's core number

  xTaskCreatePinnedToCore(                            //Task_0 creation
    loop0,    //Function for the task 
    "Task0",  //Name of the task
    10000,     //Stack size (word)
    NULL,     ///Variable input type
    0,        //Piority
    &Task0,   //Task handle address
    0);       //Task's core number
}

void loop0(void *parameter){                     //Task 0 whitch is responsible for changing parameters of LED's strip and displaying values and menu
  for(;;){  //Endless loop
  char command=Button();                                                        //Reading command
  switch (command){                                                             //Execute command depending on button as follows:
    case 'u': if (freq >= MAX_FREQ-1) freq = MAX_FREQ; else freq++; break;        //Changing frequency in whitch LED's is blinking
    case 'd': if (freq <= 2) freq = 1; else freq--; break;                        //↑
    
    case 'r': if (col_nr >= 4) col_nr = 5; else col_nr++;break;                   //Changing color profile first five are default, the last one is user's profile
    case 'l': if (col_nr <= 1) col_nr = 0; else col_nr--;break;                   //↑
    
    case '1': if (col_r >= MAX_Col_Val-1) col_r = MAX_Col_Val; else col_r++;  break;  //Changing the brightnes of Red component (user's profile)
    case '4': if (col_r <= 1) col_r = 0; else col_r--; break;                         //↑
    
    case '2': if (col_g >= MAX_Col_Val-1) col_g = MAX_Col_Val; else col_g++; break;   //Changing the brightnes of Green component (user's profile)
    case '5': if (col_g <= 1) col_g = 0; else col_g--; break;                         //↑

    case '3': if (col_b >= MAX_Col_Val-1) col_b = MAX_Col_Val; else col_b++; break;   //Changing the brightnes of Blue component (user's profile)
    case '6': if (col_b <= 1) col_b = 0; else col_b--; break;                         //↑

    case '7': if(k_counter==0){if (space >= MAX_SPACE-1) space = MAX_SPACE; else space++;}break;          //Changing how many blank LED's should be between last diode in row before and first diode of next row
    case '*': if(k_counter==0){if (space <= 2) space = 1; else space--;} break;                           //↑
    
    case '8': if(k_counter==0){if (row >= MAX_ROW-1) row = MAX_ROW; else row++;}  break;                  //Changing the how many LED's should be lighted in a row
    case '0': if(k_counter==0){if (row <= 2) row = 1; else row--;} break;//                               //↑
    
    case '9': if(k_counter!=2){if (address >= LEDS_COUNT-1) address = LEDS_COUNT; else address++;} break; //Changing the start adress of the first diode, due to it pusshing the diodes in relative direction
    case '#': if(k_counter!=2){if (address <= 1) address = 0; else address--;} break;                     //↑
           
    case 'k': k_counter++; if(k_counter>2)k_counter=0;break;    //Changing the mode (Multi diode/Single diode/Pause)
    default:   break;  
    }
  if(prev_command!=command){Menu();}      //Checking if button has been pressed, if yes then actualise the 
  prev_command=command;                   //Remembering last command from remote
  }
}


void loop1(void *parameter){   //Task 0 whitch is responsible for controling LED strip
  for(;;){    //Endless loop
    int prev_t=millis();    //Saving starting time of current cycle
    if (k_counter!=2){      //Checking the current mode 
      if (k_counter==0){    //Multi diode mode
          for (int i = address; i < LEDS_COUNT; i=i+space+row-1){                                                                 //↓
              for (int j = 0; j <row; j++){strip.setLedColorData(i+j, color[col_nr][0], color[col_nr][1], color[col_nr][2]);}}    //Turning particular LED's of strip
          strip.show();                                                                                                           //↑
          //digitalWrite(ledPin, HIGH);   //Didgital output for testing, to test the time piriod on osciloscope please uncomment this line, signal pin is 5
          delay(500/freq-millis()+prev_t);  //The half period for turrning on LED's, delay time is (0,5 sec /frequency - The time at which the for performed

          prev_t=millis();                                                      //Saving time before starting turning off subcycle
          for (int i = 0; i < LEDS_COUNT; i++)                                  //↓
            {strip.setLedColorData(i,color[0][0], color[0][1], color[0][2]);}   //Turning strip off all LED's        
          strip.show();                                                         //↑
          //digitalWrite(ledPin, LOW);  //Didgital output for testing, to test the time piriod on osciloscope please uncomment this line, signal pin is 5
          delay(500/freq-millis()+prev_t); //The half period for turrning off LED's, delay time is (0,5 sec /frequency - The time at which the for performed
          }
      else if (k_counter==1){  //Single diode mode
          strip.setLedColorData(address, color[col_nr][0], color[col_nr][1], color[col_nr][2]);   //Turning particular single LED on strip
          strip.show();
          //digitalWrite(ledPin, HIGH);       //Didgital output for testing, to test the time piriod on osciloscope please uncomment this line, signal pin is 5
          delay(500/freq-millis()+prev_t);    //The half period for turrning on LED's, delay time is (0,5 sec /frequency - The time at which the for performed
          
          prev_t=millis();                                                     //Saving time before starting turning off subcycle
          for (int i = 0; i < LEDS_COUNT; i++)                                 //↓
            {strip.setLedColorData(i,color[0][0], color[0][1], color[0][2]);}  //Turning strip off all LED's          
          strip.show();                                                        //↑
          //digitalWrite(ledPin, LOW);  //Didgital output for testing, to test the time piriod on osciloscope please uncomment this line, signal pin is 5   
          delay(500/freq-millis()+prev_t); //The half period for turrning off LED's, delay time is (0,5 sec /frequency - The time at which the for function performed
          }
      }
  }
}

void loop(){
  delay(1);     //In main loop it must be some function, if it is not used - there can be non-influential function as delay
  }
